#include <linux/fs.h>
#include <linux/in.h>
#include <linux/init.h>
#include <linux/kernel.h>
#include <linux/kthread.h>
#include <linux/module.h>
#include <linux/net.h>
#include <linux/seq_file_net.h>
#include <linux/socket.h>
//#include <linux/types.h>
#include <linux/uaccess.h>
#include <linux/uio.h>
//#include <linux/unistd.h>
//#include <netdb.h>

#define MAX_PENDING 5
#define MESSAGE_MAX_LENGTH 256
#define SOCKET_PORT 54321

static struct task_struct *threadInfo;

static int initServerSocket(struct socket **newSocket,
struct sockaddr_in *socketAddress,char *ipAddress,unsigned short port)
{
    int len = -1;

    len = sock_create_kern(&init_net,PF_INET,SOCK_STREAM,IPPROTO_TCP,
    newSocket);
    if (len < 0) {
        printk(KERN_INFO "Error: Could not create socket.\n");
        return -1;
    }

    memset(socketAddress,0, sizeof(*socketAddress));
    socketAddress->sin_family = AF_INET;
    socketAddress->sin_port = htons(port);
    inet_aton(ipAddress,&(socketAddress->sin_addr.s_addr));

    len = (*newSocket)->ops->bind(*newSocket,
    (struct sockaddr *)socketAddress,sizeof(*socketAddress));
    if (len < 0) {
        printk(KERN_INFO "Error: Could not bind socket to address.\n");
        return -1;
    }
    len = (*newSocket)->ops->listen(*newSocket,MAX_PENDING);
    if (len < 0) {
        printk(KERN_INFO "Error: Could not listen to socket.\n");
        return -1;
    }

    return 0;
}

static int acceptConnection(struct socket *serverSocket,
struct socket **newConnectionSocket) {
    int len = -1;
    (*newConnectionSocket)= sock_alloc();
    (*newConnectionSocket)->type = serverSocket->type;
    (*newConnectionSocket)->ops = serverSocket->ops;
    len = serverSocket->ops->accept(serverSocket,
    *newConnectionSocket, 0, false);
    if (len < 0) {
        printk(KERN_INFO "Error: Could not connect.\n");
        return -1;
    }
    return 0;
}

static void configMessage(struct msghdr *message,struct kvec **kv,
struct iovec **iov,char **messageBuffer,
unsigned long int messageLength,unsigned int mode) {
    message->msg_name = NULL;
    message->msg_namelen = 0;
    message->msg_control = NULL;
    message->msg_controllen = 0;
    message->msg_flags = MSG_DONTWAIT;
    message->msg_iocb = NULL;
    (*iov)->iov_len = messageLength;
    (*iov)->iov_base = *messageBuffer;
    iov_iter_init(&message->msg_iter,mode,*iov,1,1);
    (*kv)->iov_len = messageLength;
    (*kv)->iov_base = *messageBuffer;
}

static int sendMessage(struct socket *socketConnection,
char **message,unsigned long int messageLength) {
    struct msghdr outputMessage;
    struct iovec *iovp, iov[1];
    struct kvec *kvp, kv[1];
    int len = -1;
    iovp = iov;
    kvp = kv;

    configMessage(&outputMessage,&kvp,&iovp,message,messageLength,WRITE
    );

    len = kernel_sendmsg(socketConnection,&outputMessage,kvp,
    1,kv[0].iov_len);
    if (len < 0) {
        printk(KERN_INFO "Error: Could not send message\n");
        return -1;
    }
    return len;
}

static int ReadMessage(struct socket *socketConnection,
char **message) {
    struct msghdr inputMessage;
    struct iovec *iovp, iov[1];
    struct kvec *kvp, kv[1];
    int len = -1;
    iovp = iov;
    kvp = kv;

    configMessage(&inputMessage,&kvp,&iovp,message,MESSAGE_MAX_LENGTH,
    READ);

    len = kernel_recvmsg(socketConnection,&inputMessage,kvp,
    1,kv[0].iov_len,0);
    if (len < 0) {
        printk(KERN_INFO "Error: Could not receive message.\n");
        return -1;
    }
    return len;
}

static int socketServer(void *unused) {
    unsigned int messageLength;
    char outputBuffer[MESSAGE_MAX_LENGTH],
    inputBuffer[MESSAGE_MAX_LENGTH];
    struct sockaddr_in socketAddress;
    struct socket *defaultSocket, *newConnectionSocket;
    int len = -1;

    printk(KERN_INFO "Starting socket server...\n");
    printk(KERN_INFO "Kernel thread created as: %s [PID=%d]\n",
    current->comm,current->pid);

    len = initServerSocket(&defaultSocket,&socketAddress,"0.0.0.0",
    SERVER_PORT);
    if (len < 0) {
        printk(KERN_INFO "Error: Could not create server socket.\n");
        return -1;
    }

    printk(KERN_INFO "Waiting for client connections.\n");

    len = acceptConnection(defaultSocket,&newConnectionSocket);
    if (len < 0) {
        printk(KERN_INFO "Error: Could not connect.\n");
        return -1;
    }

    printk(KERN_INFO "Connection established.\n");

    len = receiveMessage(newConnectionSocket,&inputMessage);
    if (len < 0) {
        printk(KERN_INFO "Error: Could not send message.\n");
        return -1;
    }
    inputBuffer[len] = '\0';
    printk (KERN_INFO "Client says: %s %d\n",
    inputBuffer, len);
  
    messageLength = 14;
    outputBuffer[0] = 'H'; outputBuffer[1] = 'e';
    outputBuffer[2] = 'l'; outputBuffer[3] = 'l';
    outputBuffer[4] = 'o'; outputBuffer[5] = ',';
    outputBuffer[6] = ' '; outputBuffer[7] = 'c';
    outputBuffer[8] = 'l'; outputBuffer[9] = 'i';
    outputBuffer[10] = 'e'; outputBuffer[11] = 'n';
    outputBuffer[12] = 't'; outputBuffer[13] = '!';

    printk(KERN_INFO "Answering client.\n");

    len = sendMessage(newConnectionSocket,&outputMessage,
    messageLength);
    if (len < 0) {
        printk(KERN_INFO "Error: Could not receive message.\n");
        return -1;
    }

    printk(KERN_INFO "Message sent.\n");
    
    while(receiveMessage(newConnectionSocket,&inputMessage));
    sock_release(newConnectionSocket);
    printk(KERN_INFO "Client disconnected.\n");

    sock_release(defaultSocket);
    printk(KERN_INFO "Socket connection closed.\n");

    return 0;
}

static int __init initThread(void) {
    printk(KERN_INFO "Dummy thread creation\n");
    threadInfo = kthread_create(socketServer,NULL,"Dummy Thread 1");
    if(IS_ERR(threadInfo)) {
        printk(KERN_INFO "Failed creating the thread.");
    } else {
        printk(KERN_INFO "Successfully created the thread.");
	wake_up_process(threadInfo);
    }
    return 0;
}

static void __exit threadCleanup(void) {
    printk(KERN_INFO "Thread clean up.");
}

module_init(initThread);
module_exit(threadCleanup);
